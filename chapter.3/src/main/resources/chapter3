3.1 wait notify
    同步代码块中调用wait()方法释放当前锁资源并等待通知，进入阻塞状态。
    notify()方法也必须在同步代码中调用，会随机通知一个正在等待当前锁资源的线程进入就绪状态，在结束同步代码之后释放锁资源。
    notifyAll()方法会通知所有等待当前锁资源的线程，使其进入就绪状态，在当前同步代码执行完毕后，释放锁资源，再由其他线程进行锁资源的争夺。
    就绪队列和阻塞队列的相互切换。
    wait()方法执行后，立刻释放锁资源，notify()执行后会在执行完当前同步块之后在释放锁资源。
    sleep()方法不释放锁。
    处于wait()状态的线程，在被调用interrupt（）方法时会抛出异常。
    notify()的通知是随机的，并且只会通知一个。
    wait(long) 等待一定时间后自动唤醒。
    注意wait（）调用的条件在被notify（）之后应该再次检测是否满足条件，用while（）循环判断不要用if（）。
    生产者/消费者模型
        一对一都可以使用notify（）方法。
        一对多，一的可以使用notify（），多的使用notifyAll().
        一对多或者多对多是，如果使用notify（）方法可能唤醒的是同类线程，会再次进入等待状态最终导致所有线程进入等待状态，造成假死。
        注意wait（）调用的条件在被notify（）之后，条件发生改变时应及时响应，应该再次检测是否满足条件，用while（）循环判断不要用if（）。
    线程通过管道进行通信，
   PipedInputStream和PipedOutputStream    PipedReader和PipedWriter
         PipedInputStream.connect(PipedOutputStream)  或者两个调换位置均可。
3.2 join(）的使用
   主线程启动子线程后，调用子线程的join（）方法可以使主线程等待子线程执行完毕之后再执行主线程后续代码。
   join（）方法使所属线程中的对象x正常执行run（）方法中的任务，无限期阻塞当前所属线程，等待x执行完毕销毁之后再执行当前所属线程之后的代码。
   所属线程中执行玩join（）方法阻塞时，如果所属线程被中断，就会抛出异常，
   join(long)等带子线程执行一段时间后自行继续或者等待时间内子线程执行完毕销毁之后继续。
   join（long）和sleep（long）都会使当前线程暂停执行一段时间，不同的是join（long）内部调用wait（）方法实现，具有释放锁的特点，sleep（）方法不会释放锁。
   join(long)是一个同步方法，在进入方法时会获取对象的锁，在执行到内部的wait（）方法时会释放掉锁，在当前线程对象执行完毕后会再次获取锁对象。
3.3 ThreadLocal类
    ThreadLocal类每个线程调用set get都只会修改获取自己线程存放的值，不同线程之间不会互相干扰。线程的私有共享变量，在这个线程执行过程中的每一个地方，都能获取修改。
    重写initialValue()方法，可以设置线程共享变量的初始值。
3.4InheritableThreadLocal
    可以使子线程去到父线程中存的值
    重写childValue  可以在父线程值得基础上再修改。